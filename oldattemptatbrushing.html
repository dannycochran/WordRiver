<html>
<head>
<title>A River of Twitter Data</title>
<script type="text/javascript" src="lib/d3.v2.js"></script>
<link rel="stylesheet" href="styles/style.css" type="text/css" /> 

<div>
	<h1>
	<img src="lib/twitter-bird-white-on-blue1.png"/>
	A River of Twitter Words
	</h1>
</div>  

<style>
.chart {
	shape-rendering: crispEdges;
}

.mini text {
	font: 9px sans-serif;	
}

.main text {
	font: 12px sans-serif;	
}

.axis line, .axis path {
	stroke: black;
}

.miniItem {
	stroke-width: 6;	
}

.brush .extent {
	stroke: gray;
	fill: blue;
	fill-opacity: .165;
}
</style>
</head>
<body>

<script type="text/javascript">

var distanceBins = ["0-1 Miles","1-5 Miles","5-25 Miles","25-100 Miles","100-500 Miles","500-1000 Miles", "1000-3000 Miles"]

var jsonData;

d3.json("twitterWords2.json", function (json) {

jsonData=json;

var margin = {top: 20, right: 15, bottom: 15, left: 100}
  , width = 960 - margin.left - margin.right
  , height = 500 - margin.top - margin.bottom
  , miniHeight = distanceBins.length * 12 + 50
  , mainHeight = height - miniHeight - 50;

x = d3.scale.linear()
	.domain([0,168])
	.range([0, width]);
x1 = d3.scale.linear().range([0, width]);

var ext = d3.extent(distanceBins, function(d,i) { return i; });
y1 = d3.scale.linear().domain([ext[0], ext[1] + 1]).range([0, mainHeight]);
y2 = d3.scale.linear().domain([ext[0], ext[1] + 1]).range([0, miniHeight]);

var chart = d3.select('body')
	.append('svg:svg')
	.attr('width', width + margin.right + margin.left)
	.attr('height', height + margin.top + margin.bottom)
	.attr('class', 'chart');

chart.append('defs').append('clipPath')
	.attr('id', 'clip')
	.append('rect')
		.attr('width', width)
		.attr('height', mainHeight);

main = chart.append('g')
	.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
	.attr('width', width)
	.attr('height', mainHeight)
	.attr('class', 'main');

mini = chart.append('g')
	.attr('transform', 'translate(' + margin.left + ',' + (mainHeight + 60) + ')')
	.attr('width', width)
	.attr('height', miniHeight)
	.attr('class', 'mini');

// draw the distanceBins for the main chart
main.append('g').selectAll('.laneLines')
	.data(distanceBins)
	.enter().append('line')
	.attr('x1', 0)
	.attr('y1', function(d,i) { return d3.round(y1(i)) + 0.5; })
	.attr('x2', width)
	.attr('y2', function(d,i) { return d3.round(y1(i)) + 0.5; })
	.attr('stroke', function(d,i) { return 'lightgray' });

main.append('g').selectAll('.laneText')
	.data(distanceBins)
	.enter().append('text')
	.text(function(d) { return d; })
	.attr('x', -10)
	.attr('y', function(d,i) { return y1(i + .5); })
	.attr('dy', '0.5ex')
	.attr('text-anchor', 'end')
	.attr('class', 'laneText');

// draw the distanceBins for the mini chart
mini.append('g').selectAll('.laneLines')
	.data(distanceBins)
	.enter().append('line')
	.attr('x1', 0)
	.attr('y1', function(d,i) { return d3.round(y2(i)) + 0.5; })
	.attr('x2', width)
	.attr('y2', function(d,i) { return d3.round(y2(i)) + 0.5; })
	.attr('stroke', function(d) { return d === '' ? 'white' : 'lightgray' });

mini.append('g').selectAll('.laneText')
	.data(distanceBins)
	.enter().append('text')
	.text(function(d) { return d; })
	.attr('x', -10)
	.attr('y', function(d,i) { return y2(i+ 0.5); })
	.attr('dy', '0.5ex')
	.attr('text-anchor', 'end')
	.attr('class', 'laneText');

// draw the x axis
xDateAxis = d3.svg.axis()
	.scale(x)
	.orient('top')
	.ticks(20)
	.tickSize(15, 0, 0);

main.append('g')
	.attr('transform', 'translate(0,' + mainHeight + ')')
	.attr('class', 'main axis date')
	.call(xDateAxis);
	
mini.append('g')
	.attr('transform', 'translate(0,0.5)')
	.attr('class', 'axis month')
	.call(xDateAxis)
	.selectAll('text')
		.attr('dx', 9)
		.attr('dy', 12);

// draw the items
var fill = d3.scale.category20();

itemRects = main.append('g')
	.attr('clip-path', 'url(#clip)');

mini.append('g').selectAll('miniItems')
	.data(json)
	.enter().append('rect')
	.attr('class', function(d) { return 'miniItem '; })
	.attr("x",function(d,i) {return x(d.time_bin)})
	.attr("y",function(d) {return y2(d.dist_bin+.08)})
	.attr("width",x(2)-x(1))
	.attr("height",y2(1)*.5)
	.style("fill", function(d, i) {return fill(i);});
	

mini.append('g').selectAll('miniItems')
	.data(getPaths(jsonData))
	.enter().append('path')
	.attr('class', function(d) { return 'miniItem ' + d.class; })
	.attr('d', function(d) { return d.path; });

	
// invisible hit area to move around the selection window
mini.append('rect')
	.attr('pointer-events', 'painted')
	.attr('width', width)
	.attr('height', miniHeight)
	.attr('visibility', 'hidden');
/* 	.on('mouseup', moveBrush); */

// draw the selection area
brush = d3.svg.brush()
	.x(x)
	.extent([0, 5])
	.on("brush", display);
	//create g-node which contains rect, on mousedown, 

mini.append('g')
	.attr('class', 'x brush')
	.call( brush)
	.selectAll('rect')
	.attr('y', 1)
	.attr('height', miniHeight - 1);

mini.selectAll('rect.background').remove();
})

function display () {
	var fill = d3.scale.category20();
	var rects, labels
	  , minExtent = brush.extent()[0]
	  , maxExtent = brush.extent()[1]
	  , visItems = jsonData.filter(function (d) {return d.time_bin <= maxExtent && d.time_bin >= minExtent});
	mini.select('.brush').call(brush.extent([minExtent, maxExtent]));		
	console.log(minExtent,maxExtent);
	var s = brush.extent();
    if (s[1]-s[0] > 20) {
        var minExtent = Math.round((jsonData.length-1)*s[0]);
        var maxExtent = Math.round((jsonData.length-1)*s[1]);
    }

    else {
    	brush.extent([s[1],s[0]]);
    }

	x1.domain([minExtent, maxExtent]);

	if ((maxExtent - minExtent) > 1468800000) {
		xDateAxis.ticks(d3.time.mondays, 1).tickFormat(d3.time.format('%a %d'))
	}
	else if ((maxExtent - minExtent) > 172800000) {
		xDateAxis.ticks(d3.time.days, 1).tickFormat(d3.time.format('%a %d'))
	}
	else {
		xDateAxis.ticks(d3.time.hours, 4).tickFormat(d3.time.format('%I %p'))
	}

	// update the axis

	main.select('.main.axis.date').call(xDateAxis)
		.selectAll('text')
			.attr('dx', 5)
			.attr('dy', 12);

	// upate the item rects
	rects = itemRects.selectAll('rect')
		.data(visItems, function (d,i) { return i; })
		.attr('x', function(d) { return x1(d.time_bin)-40; })
		.attr('y', function(d) { return y1(d.dist_bin) + .1 * y1(1) + 0.5; })
		.attr('width', function(d) { return x(d.word.length*5) })
		.style("fill", function(d, i) {return fill(i);});	

	rects.enter().append('rect')
		.attr('x', function(d) { return x1(d.time_bin)-40; })
		.attr('y', function(d) { return y1(d.dist_bin) + .1 * y1(1) + 0.5; })
		.attr('width', function(d) { return x(d.word.length) })
		.attr('height', function(d) { return .8 * y1(1); })
		.attr('class', function(d) { return 'mainItem '; })
		.style("fill", function(d, i) {return fill(i);}); // replace this function to be based on positivity, not random color	

	rects.exit().remove();

	// update the item labels
	labels = itemRects.selectAll('text')
		.data(visItems, function (d) { return d.word; })
		.attr('x', function(d) { return x1(Math.max(d.time_bin, minExtent)) + 2 - 40; });
/* 		.style(this function should make typeface based on objectivity) */
				
	labels.enter().append('text')
		.text(function (d) { return d.word; })
		.attr('x', function(d) { return x1(Math.max(d.time_bin, minExtent)) + 2 - 40; })
		.attr('y', function(d) { return y1(d.dist_bin) + .4 * y1(1) + 0.5; })
		.attr('text-anchor', 'start')
		.attr('class', 'itemLabel');

	labels.exit().remove();
}

/*
function moveBrush () {
	var origin = d3.mouse(this)
	  , point = x.invert(origin[0])
	  , halfExtent = (brush.extent()[1] - brush.extent()[0] / 2)
	  , start = (point - halfExtent)
	  , end = (point + halfExtent);
	  console.log(this);
	brush.extent([start,end]);
	display();
}
*/


// generates a single path for each item class in the mini display
// ugly - but draws mini 2x faster than append lines or line generator
// is there a better way to do a bunch of lines as a single path with d3?
function getPaths(jsonData) {
	var paths = {}, d, offset = .5 * y2(1) + 0.5, result = [];
	for (var i = 0; i < jsonData.length; i++) {
		d = jsonData[i];
		if (!paths[d.class]) paths[d.class] = '';	
		paths[d.class] += ['M',x1(d.time_bin+2),(y2(d.dist_bin+1) + offset),'H',x1(d.time_bin+.01)].join(' ');
	}

	for (var className in paths) {
		result.push({class: className, path: paths[className]});
	}

	return result;
}

</script>
</body>
</html>